dij求最短路堆优化的情形下,一种是在遍历邻接点的循环外更新dis,如果dis有,说明被之前更小的更新过(每次出堆的总是之后都不可能被更新的元素)
如果dis没有,则直接设置dis;
另一种情形是在循环内更新dis,这种情形每次更新的发起者(源点)的dis已经确定,每次pop出来的点必须不重复

Floyd算法中如果dis[i][i]统一置为0,则跑完后dis[i][i]依旧为0;
若规定dis[i][i]不为0(即i需要经过某条路径回到i才算dis[i][i])则跑完Floyd算法后可以得到最短的包含i的回路
void floyd()
{
    //一开始要将相邻的点的距离置为所有重边中最短的
    //不相邻的点之间的dis置为inf
    for(int k=1;k<=n;k++)
    //这里的注意点：枚举中间点的循环放在最前面
    for(int i=1;i<=n;i++)
    for(int j=1;j<=n;j++)
    dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]);
    //松弛操作。
}//Floyd图论求最短路。
